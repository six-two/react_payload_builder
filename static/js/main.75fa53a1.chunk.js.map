{"version":3,"sources":["app/views/list/ReorderableListItemView.tsx","app/views/list/ReorderableListView.tsx","app/hex/ByteString.ts","app/hex/Padding.ts","app/hex/Integer.ts","app/hex/String.ts","app/hex/ByteStringBuilder.ts","app/views/CopyButton.tsx","app/views/ChooseOptionView.tsx","app/views/PresetOrCustomString.tsx","app/views/hex/OutputView.tsx","app/Common.ts","app/views/hex/PaddingEditView.tsx","app/views/hex/IntegerEditView.tsx","app/views/hex/StringEditView.tsx","app/views/hex/HexElementView.tsx","App.tsx","serviceWorker.js","index.js"],"names":["ListItemView","onMoveUp","props","index","onItemsSwap","onMoveDown","isLast","onDelete","onItemDelete","className","this","children","type","value","onClick","disabled","React","Component","ReorderableListView","onItemAdd","copy","state","entries","slice","data","newItemData","length","entry","key","nextId","push","onChange","onItemChange","newValue","onItemSwapped","indexFrom","indexTo","tmp","onItemDeleted","splice","map","elem","childProps","createElement","entryClass","newArray","setState","ByteString","str","bytes","updateByteCount","i","isNaN","parseInt","Error","invStr","hex","result","Utils","pattern","paddToLength","padding","previousByteStrings","offset","missing","throwBadInputError","patternBytes","repeatCount","Math","floor","incompleteSize","paddingStr","repeat","incompletePaddingStr","join","MAX_INT_MAP","Map","set","BYTE_COUNT_MAP","numberString","numberType","integer","num","parseNumber","maxOrNull","get","max","BigInt","e","string","replace","littleEndian","error","getErrorMessage","byteCount","toString","missingChars","fromHex","getReversed","values","count","ReversedUtils","ERROR_BYTE_STRING","message","name","ByteStringBuilder","blueprintList","processed","previous","toBytes","byteStrings","errorMessage","blueprint","Padding","paddingToBytes","Int","integerToBytes","Str","stringToBytes","CopyButton","event","text","copiedText","buttonText","ChooseOptionView","target","hidden","prompt","options","PresetOrCustomStringView","onTypeChange","newType","option","isCustom","lastCustomValue","undefined","onValueChange","customFormat","customOption","keys","FORMAT_MAP","OutputView","onFormatChange","newFormat","format","default_format_value","parts","split","escapedTaggedStrings","getBytesStrings","blueprints","bs","unescaped","textToCopy","tbs","isValidRepeatCountWhileEditing","repeatCountString","Number","LABELS","PaddingEditView","onNumberChange","Common","onPatternChange","changedValues","Object","assign","INT_SIZES","LABLES","IntegerEditView","test","LABELS_NORMAL","LABELS_REVERSED","StringEditView","labels","TYPE_MAP","defaultValues","viewClass","Integer","String","Pad","TYPES","getTypeInfo","ret","HexElementView","onChildChange","newValues","renderChild","newData","App","onListChange","newBlueprints","href","v","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","console"],"mappings":"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","file":"static/js/main.75fa53a1.chunk.js","sourcesContent":["import React from 'react';\n\nexport default class ListItemView extends React.Component<Props, {}> {\n  render() {\n    return (\n      <li className=\"list-item multi-colored\">\n        {this.props.children}\n        <div className=\"list-item-controls\">\n          <input type=\"button\"\n            value=\"Up\"\n            onClick={this.onMoveUp}\n            disabled={this.props.index === 0} />\n          <input type=\"button\"\n            value=\"Down\"\n            onClick={this.onMoveDown}\n            disabled={this.props.isLast} />\n          <input type=\"button\"\n            value=\"Delete\"\n            onClick={this.onDelete} />\n        </div>\n      </li>);\n  }\n\n  onMoveUp = () => {\n    if (this.props.index > 0) {\n      this.props.onItemsSwap(this.props.index, this.props.index - 1);\n    }\n  }\n\n  onMoveDown = () => {\n    if (!this.props.isLast) {\n      this.props.onItemsSwap(this.props.index, this.props.index + 1);\n    }\n  }\n\n  onDelete = () => {\n    this.props.onItemDelete(this.props.index);\n  }\n}\n\ninterface Props {\n  children?: any,\n  index: number,\n  isLast: boolean,\n  onItemsSwap: (srcIndex: number, dstIndex: number) => void,\n  onItemDelete: (index: number) => void,\n}\n","import React from 'react';\nimport ListItemView from './ReorderableListItemView';\n\n\nexport default class ReorderableListView extends React.Component<Props, State>{\n  constructor(props: Props) {\n    super(props);\n    this.state = { entries: [], nextId: 0 };\n  }\n\n  render() {\n    return (\n      <div>\n        <h2>Hex builder</h2>\n        <ol className=\"list\">\n          {this.state.entries.map((elem, index) => {\n            const childProps = { index: index, data: elem.data, onChange: this.onItemChange };\n            return (\n              <ListItemView\n                index={index}\n                key={elem.key}\n                isLast={index + 1 === this.state.entries.length}\n                onItemDelete={this.onItemDeleted}\n                onItemsSwap={this.onItemSwapped} >\n\n                {React.createElement(this.props.entryClass, childProps)}\n              </ListItemView>\n            );\n          }\n          )}\n          <li key={-1}>\n            <input type=\"button\"\n              value=\"Add new element\"\n              onClick={this.onItemAdd} />\n          </li>\n        </ol>\n      </div>\n    );\n  }\n\n  onItemAdd = () => {\n    var copy = this.state.entries.slice();\n    var data = this.props.newItemData(copy.length);\n    let entry: Entry = { key: this.state.nextId, data: data };\n    copy.push(entry);\n    this.onChange(copy, this.state.nextId + 1);\n  }\n\n  onItemChange = (index: number, newValue: Entry) => {\n    var copy = this.state.entries.slice();\n    let entry: Entry = { key: copy[index].key, data: newValue };\n    copy[index] = entry;\n    this.onChange(copy, this.state.nextId);\n  }\n\n  onItemSwapped = (indexFrom: number, indexTo: number) => {\n    var copy = this.state.entries.slice();\n    const tmp = copy[indexFrom];\n    copy[indexFrom] = copy[indexTo];\n    copy[indexTo] = tmp;\n    this.onChange(copy, this.state.nextId);\n  }\n\n  onItemDeleted = (index: number) => {\n    var copy = this.state.entries.slice();\n    copy.splice(index, 1);\n    this.onChange(copy, this.state.nextId);\n  }\n\n  onChange(newArray: Entry[], nextId: number) {\n    this.setState({ entries: newArray, nextId: nextId });\n    this.props.onChange(newArray);\n  }\n}\n\ninterface Props {\n  entryClass: any,\n  onChange: (entries: Entry[]) => void,\n  newItemData: (index: number) => any,\n}\n\ninterface State {\n  entries: Entry[],\n  nextId: number,\n}\n\ninterface Entry {\n  key: number,\n  data: any,\n}\n","export default class ByteString {\n  str: string;\n  bytes: string[];\n\n  constructor(str: string) {\n    this.str = str;\n    this.bytes = []\n    this.updateByteCount();\n  }\n\n  updateByteCount() {\n    let i = 0;\n    this.bytes = []\n    while (i < this.str.length) {\n      if (this.str[i] === \"\\\\\" && i + 1 < this.str.length && this.str[i + 1] === \"x\") {\n        if (isNaN(parseInt(this.str[i + 2], 16)) || isNaN(parseInt(this.str[i + 3], 16))) {\n          throw new Error(\"Not a valid hex escape: '\" + this.str.slice(i + 2, i + 4) + \"'\");\n        }\n        this.bytes.push(this.str.slice(i, i + 4));\n        i += 4;\n      } else {\n        this.bytes.push(this.str[i]);\n        i += 1;\n      }\n    }\n  }\n\n  getReversed(): ByteString {//TODO later: is pretty inefficient\n    let invStr = \"\";\n    for (let i = this.bytes.length - 1; i >= 0; i--) {\n      invStr += this.bytes[i];\n    }\n    return new ByteString(invStr);\n  }\n\n  static fromHex(hex: string): ByteString {\n    if (hex.length % 2 === 1) {\n      throw new Error(\"Hex has odd length\");\n    }\n    let result = \"\";\n    for (var i = 0; i < hex.length; i += 2) {\n      result += \"\\\\x\" + hex.slice(i, i + 2);\n    }\n    return new ByteString(result);\n  }\n}\n","import ByteString from \"./ByteString\";\nimport {throwBadInputError} from \"./ByteStringBuilder\";\n\nexport interface Values {\n  paddToLength: number,\n  pattern: string,\n  type: string,\n}\n\nexport const TYPE = \"Padding\";\n\n\nexport class Utils {\n  static defaultValues(): Values {\n    return {\n      pattern: \"A\",\n      paddToLength: 1,\n      type: TYPE,\n    };\n  }\n\n  static paddingToBytes(padding: Values, previousByteStrings: ByteString[]): ByteString {\n    var offset = 0;\n    for (var i = 0; i < previousByteStrings.length; i++) {\n      offset += previousByteStrings[i].bytes.length;\n    }\n    var missing = padding.paddToLength - offset;\n    if (missing < 0) {\n      throwBadInputError(`Padding should be applied up to index ${padding.paddToLength}, but the string is already longer than that (length=${offset})`);\n    }\n    const patternBytes = new ByteString(padding.pattern ? padding.pattern : \"?\");\n    const repeatCount = Math.floor(missing / patternBytes.bytes.length);\n    const incompleteSize = missing - (repeatCount * patternBytes.bytes.length)\n    var paddingStr: string = patternBytes.str.repeat(repeatCount);\n    var incompletePadding: string[] = patternBytes.bytes.slice(0, incompleteSize);\n    let incompletePaddingStr: string = incompletePadding.join(\"\");\n    return new ByteString(paddingStr + incompletePaddingStr);\n  }\n}\n\nexport default Values;\n","import ByteString from \"./ByteString\";\nimport {throwBadInputError} from \"./ByteStringBuilder\";\n\nexport const INT_8 = \"8 bit\";\nexport const INT_16 = \"16 bit\";\nexport const INT_32 = \"32 bit\";\nexport const INT_64 = \"64 bit\";\nexport const TYPE = \"Integer\";\n\nconst MAX_INT_MAP = new Map<string, bigint>();\nMAX_INT_MAP.set(INT_8, 0xffn);\nMAX_INT_MAP.set(INT_16, 0xffffn);\nMAX_INT_MAP.set(INT_32, 0xffffffffn);\nMAX_INT_MAP.set(INT_64, 0xffffffffffffffffn);\n\nconst BYTE_COUNT_MAP = new Map<string, number>();\nBYTE_COUNT_MAP.set(INT_8, 1);\nBYTE_COUNT_MAP.set(INT_16, 2);\nBYTE_COUNT_MAP.set(INT_32, 4);\nBYTE_COUNT_MAP.set(INT_64, 8);\n\nexport interface Values {\n  numberString: string,\n  numberType: string,\n  type: string,\n}\n\nexport class Utils {\n  static defaultValues(): Values {\n    return {\n      numberString: \"0x41414141\",\n      numberType: INT_32,\n      type: TYPE,\n    };\n  }\n\n  static getErrorMessage(integer: Values) {\n    try {\n      var num: bigint = Utils.parseNumber(integer.numberString);\n      const type: string = integer.numberType;\n      let maxOrNull = MAX_INT_MAP.get(type);\n      if (!maxOrNull) {\n        throw new Error(`Unknown number type: ${type}`);\n      } else {\n        let max: bigint = maxOrNull;\n        if (num > max) {\n          return `Number to big for '${type}'`;\n        }\n        if (num < 0n) {\n          const min: bigint = (max + 1n) / BigInt(-2);\n          if (num < min) {\n            return `Number to big for '${type}'`;\n          }\n        }\n      }\n    } catch (e) {\n      return \"Parsing integer failed\";\n    }\n  }\n\n  static parseNumber(string: string): bigint {\n    // Remove characters that can be used to make strings more human readable\n    string = string.replace(/[\\s_]+/g, \"\");\n    return BigInt(string);\n  }\n\n\n  static integerToBytes(integer: Values,\n    littleEndian: boolean = true): ByteString {\n    var error = Utils.getErrorMessage(integer);\n    if (error) {\n      throwBadInputError(error);\n    }\n    var num: bigint = Utils.parseNumber(integer.numberString);\n    let max = MAX_INT_MAP.get(integer.numberType);\n    let byteCount = BYTE_COUNT_MAP.get(integer.numberType);\n    if (!max || !byteCount) {\n      throw new Error(`Unknown number type: ${integer.numberType}`);\n    }\n    if (num < 0n) {\n      num += max + 1n;\n    }\n    let hex: string = num.toString(16);\n    let missingChars = 2 * byteCount - hex.length;\n    hex = \"0\".repeat(missingChars) + hex;//padd with leading zeros\n    let bytes: ByteString = ByteString.fromHex(hex);\n    return littleEndian ? bytes.getReversed() : bytes;\n  }\n}\n","import ByteString from \"./ByteString\";\n\nexport interface Values {\n  repeatCount: number,\n  pattern: string,\n  type: string,\n}\n\nexport const TYPE = \"String\";\nexport const TYPE_REVERSED = \"String (reversed)\";\n\n\nexport class Utils {\n  static defaultValues(): Values {\n    return {\n      pattern: \"A\",\n      repeatCount: 1,\n      type: TYPE,\n    };\n  }\n\n  static stringToBytes(values: Values): ByteString {\n    const count = values.repeatCount;\n    let pattern = values.pattern.repeat(count);\n    return new ByteString(pattern);\n  }\n}\n\nexport class ReversedUtils {\n  static defaultValues(): Values {\n    return {\n      pattern: \"A\",\n      repeatCount: 1,\n      type: TYPE_REVERSED,\n    };\n  }\n\n  static stringToBytes(values: Values): ByteString {\n    const count = values.repeatCount;\n    let revPattern = new ByteString(values.pattern).getReversed().str;\n    let pattern = revPattern.repeat(count);\n    return new ByteString(pattern);\n\n  }\n}\n\nexport default Values;\n","import * as Padding from './Padding';\nimport * as Int from './Integer';\nimport * as Str from './String';\nimport ByteString from './ByteString';\n\nconst BAD_INPUT_ERROR_NAME = \"BadInputError\";\nconst ERROR_BYTE_STRING: TaggedByteString = {\n  key: -1,\n  data: new ByteString(\"Error: Please check your inputs. @dev: This message should not be shown\"),\n}\n\nexport function throwBadInputError(message: string) {\n  // This function creates an error that signals, that it was caused by bad user input\n  let e = new Error(message || \"Something went wrong. Please check your inputs\")\n  e.name = BAD_INPUT_ERROR_NAME;\n  throw e;\n}\n\nexport class ByteStringBuilder {\n  static getBytesStrings(blueprintList: Blueprint[]): BuilderResult {\n    let i: number = 0;\n    try {\n      let processed: TaggedByteString[] = [];\n      let previous: ByteString[] = [];\n      for (i = 0; i < blueprintList.length; i++) {\n        let bytes: ByteString = ByteStringBuilder.toBytes(blueprintList[i].data, previous);\n        let entry = { key: blueprintList[i].key, data: bytes };\n        previous.push(bytes);\n        processed.push(entry);\n      }\n      return { byteStrings: processed };\n    } catch (e) {\n      if (e.name === BAD_INPUT_ERROR_NAME) {\n        return { errorMessage: `Error in input ${i + 1}: ${e.message}`, byteStrings: [ERROR_BYTE_STRING] };\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  static toBytes(blueprint: any, previousByteStrings: ByteString[]): ByteString {\n    switch (blueprint.type) {\n      case Padding.TYPE:\n        return Padding.Utils.paddingToBytes(blueprint, previousByteStrings);\n      case Int.TYPE:\n        let littleEndian = true;\n        return Int.Utils.integerToBytes(blueprint, littleEndian);\n      case Str.TYPE:\n        return Str.Utils.stringToBytes(blueprint);\n      case Str.TYPE_REVERSED:\n        return Str.ReversedUtils.stringToBytes(blueprint);\n      default:\n        return new ByteString(\"<Unknown type>\");\n    }\n  }\n};\n\nexport interface Blueprint {\n  key: number,\n  data: any,\n}\n\nexport interface BuilderResult {\n  byteStrings: TaggedByteString[],\n  errorMessage?: string,\n}\n\nexport interface TaggedByteString {\n  key: number,\n  data: ByteString,\n}\n\nexport default ByteStringBuilder;\n","import React from 'react';\nimport copy from 'copy-to-clipboard';\n\nexport default class CopyButton extends React.Component<Props, State> {\n  constructor(props: Props) {\n    super(props);\n    this.state = { copiedText: null };\n  }\n\n  render() {\n    const alreadyCopied = this.props.text === this.state.copiedText;\n    const buttonText = alreadyCopied ? \"Copied\" : \"Copy\";\n    return (\n      <button onClick={this.onClick}>\n        {buttonText}\n      </button>\n    );\n  }\n\n  onClick = (event: any) => {\n    const text = this.props.text;\n    copy(text);\n    this.setState({ copiedText: text });\n  }\n}\n\ninterface State {\n  copiedText: string | null,\n}\n\nexport interface Props {\n  text: string,\n}\n","import React from 'react';\n\nexport class ChooseOptionView extends React.Component<ChooseOptionViewProps, {}> {\n  static defaultValue(): string {\n    return \"\";\n  }\n\n  render() {\n    return (<select onChange={(event) => { this.props.onChange(event.target.value) }} value={this.props.value}>\n      <option value=\"\" key={-1} disabled hidden>\n        {this.props.prompt ? this.props.prompt : \"Choose a option\"}\n      </option>\n      {this.props.options.map((value: any, i: number) => {\n        // Here using key=index should be ok, since the order should not change\n        return <option value={value} key={i}>{value}</option>;\n      })}\n    </select>);\n  }\n}\n\nexport interface ChooseOptionViewProps {\n  prompt?: string,\n  value: string,\n  options: string[],\n  onChange: (newValue: string) => void,\n}\n\nexport default ChooseOptionView;\n","import React from 'react';\nimport ChooseOptionView from './ChooseOptionView';\n\n\nexport class PresetOrCustomStringView extends React.Component<Props, State> {\n  constructor(props: Props) {\n    super(props);\n    let customFormat = props.options.get(props.customOption);\n    if (customFormat === undefined) {\n      throw new Error(\"Initial value for customOption is not suppplied\");\n    }\n\n    this.state = { lastCustomValue: customFormat };\n  }\n\n  render() {\n    return (\n      <div>\n        <ChooseOptionView\n          value={this.props.values.option}\n          onChange={this.onTypeChange}\n          options={[...this.props.options.keys()]} />\n        {this.isCustom() ?\n          <input type=\"text\"\n            value={this.props.values.value}\n            onChange={this.onValueChange} /> : null}\n      </div>\n    );\n  }\n\n  isCustom(option: string | undefined = undefined): boolean {\n    option = option ?? this.props.values.option;\n    return option === this.props.customOption;\n  }\n\n  onTypeChange = (newType: string) => {\n    if (newType === this.props.values.option) {\n      return; //no type change\n    }\n    let value;\n    if (this.isCustom(newType)) {\n      // preset -> custom\n      // load last used custom value\n      value = this.state.lastCustomValue;\n    }\n    else {\n      if (this.isCustom()) {\n        // custom -> preset\n        // store current custom value for the future\n        this.setState({ lastCustomValue: this.props.values.value });\n      }\n      value = this.props.options.get(newType);\n      if (value === undefined) {\n        throw new Error(\"[BUG] Type has no value mapped\"); //should never happen\n      }\n    }\n    const values: Values = { option: newType, value: value };\n    this.props.onChange(values);\n  }\n\n  onValueChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n    if (this.isCustom()) {//should be true\n      const values: Values = {\n        option: this.props.values.option,\n        value: event.target.value,\n      };\n      this.props.onChange(values);\n    }\n  }\n}\n\nexport interface Props {\n  options: Map<string, string>,\n  customOption: string,\n  values: Values,\n  onChange: (newValues: Values) => void,\n}\n\ninterface State {\n  lastCustomValue: string,//changing this has no effect on the rendering of the component\n}\n\nexport interface Values {\n  option: string,\n  value: string,\n}\n\nexport default PresetOrCustomStringView;\n","import React from 'react';\nimport { TaggedByteString, Blueprint, ByteStringBuilder } from '../../hex/ByteStringBuilder';\nimport CopyButton from '../CopyButton';\nimport * as FormatChooser from \"../PresetOrCustomString\";\n\n\nconst CUSTOM_FORMAT = \"custom\";\nconst DEFAULT_FORMAT = \"raw\";\nconst FORMAT_MAP = new Map<string, string>();\nFORMAT_MAP.set(\"python\", \"python -c 'print(\\\"%s\\\")'\");\nFORMAT_MAP.set(\"printf\", \"printf '%s'\");\nFORMAT_MAP.set(DEFAULT_FORMAT, \"%s\");\nFORMAT_MAP.set(CUSTOM_FORMAT, \"your_command --flags '%s'\")\n\nfunction escapeOutputString(unescaped: string): string {\n  // escape quote signs since they could mess up passing the payload to a program (eg printf)\n  return unescaped.replace(/'/g, \"\\\\x27\").replace(/\"/g, \"\\\\x22\")\n    // escape spaces, since the html does not handle consecutive whitespaces well\n    .replace(/ /g, \"\\\\x20\");\n}\n\nexport default class OutputView extends React.Component<Props, State> {\n  constructor(props: Props) {\n    super(props);\n    const default_format_value = FORMAT_MAP.get(DEFAULT_FORMAT) ?? \"%s\";\n    this.state = {\n      format: { option: DEFAULT_FORMAT, value: default_format_value }\n    };\n  }\n\n  render() {\n    var error;\n    const parts = this.state.format.value.split(\"%s\");\n    if (parts.length !== 2) {\n      error = 'Format has to contain exactly one \"%s\" (without the quotes)';\n    }\n\n    let escapedTaggedStrings: TaggedString[] = [];//to make the type check happy\n    let result = ByteStringBuilder.getBytesStrings(this.props.blueprints);\n    if (result.errorMessage) {\n      error = result.errorMessage\n    } else {\n      escapedTaggedStrings = result.byteStrings.map((bs: TaggedByteString) => {\n        let taggedStr: TaggedString = {\n          key: bs.key,\n          str: escapeOutputString(bs.data.str),\n        };\n        return taggedStr;\n      });\n    }\n    let textToCopy = escapedTaggedStrings.map((tbs) => { return tbs.str }).join(\"\");\n    textToCopy = parts[0] + textToCopy + parts[1];\n\n    return (\n      <div>\n        {\"Output format: \"}\n        <FormatChooser.PresetOrCustomStringView options={FORMAT_MAP}\n          values={this.state.format}\n          customOption={CUSTOM_FORMAT}\n          onChange={this.onFormatChange} />\n        <br />\n        {error ?\n          <span className=\"err-msg\">{error}</span> :\n          <div className=\"byteOutput\">\n            <CopyButton text={textToCopy} />\n            <br />\n            {parts[0]}\n            <span>\n              {escapedTaggedStrings.map((value: TaggedString) => {\n                return <span className=\"multi-colored\" key={value.key}>{value.str}</span>;\n              })}\n            </span>\n            {parts[1]}\n          </div>\n        }\n      </div>\n    );\n  }\n\n  onFormatChange = (newFormat: FormatChooser.Values) => {\n    this.setState({ format: newFormat });\n  }\n}\n\ninterface Props {\n  blueprints: Blueprint[],\n}\n\ninterface State {\n  format: FormatChooser.Values,\n}\n\ninterface TaggedString {\n  str: string,\n  key: number,\n}\n","// Do not allow arbitrary large values for repeatCount, paddToLength, etc to\n// prevent you from accidentially DoS'ing yourself. Happened to me ;D\nexport const MAX_REPEAT_INT = 100000 - 1;\nexport const OUTPUT_COLORS = [\"red\", \"green\", \"blue\"];\n\nexport function isValidRepeatCountWhileEditing(repeatCountString: string): boolean {\n  if (repeatCountString === \"\") {\n    // allow the empty string while editing\n    return true;\n  } else {\n    const repeatCount = Number(repeatCountString);\n    return (!isNaN(repeatCount)) && (repeatCount > 0) && (repeatCount <= MAX_REPEAT_INT);\n  }\n}\n\nexport function clamp(minInclusive: number, value: number, maxInclusive: number) {\n  return Math.max(minInclusive, Math.min(value, maxInclusive));\n};\n","import React from 'react';\nimport * as Padding from '../../hex/Padding';\nimport * as Common from '../../Common';\n\nconst LABELS = [\"Repeat \", \" up to index \"];\n\nexport default class PaddingEditView extends React.Component<Props> {\n  render() {\n    return (\n      <div>\n        {LABELS[0]}\n        <input type=\"text\"\n          value={this.props.values.pattern}\n          onChange={this.onPatternChange} />\n        {LABELS[1]}\n        <input type=\"text\"\n          value={this.props.values.paddToLength}\n          onChange={this.onNumberChange} />\n      </div>);\n  }\n\n  onNumberChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n    if (Common.isValidRepeatCountWhileEditing(event.target.value)) {\n      this.onChange({ paddToLength: event.target.value });\n    }\n  }\n\n  onPatternChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n    this.onChange({ pattern: event.target.value });\n  }\n\n  onChange(changedValues: any) {\n    this.props.onChange(Object.assign({}, this.props.values, changedValues));\n  }\n}\n\nexport interface Props {\n  values: Padding.Values,\n  onChange: (newValues: Padding.Values) => void,\n}\n","import React from 'react';\nimport ChooseOptionView from '../ChooseOptionView';\nimport * as Int from \"../../hex/Integer\";\n\nconst INT_SIZES = [Int.INT_8, Int.INT_16, Int.INT_32, Int.INT_64];\nconst LABLES = [\" as \", \" integer\"]\n\nexport default class IntegerEditView extends React.Component<Props, {}> {\n  render() {\n    return (\n      <div>\n        <input type=\"text\"\n          value={this.props.values.numberString}\n          onChange={this.onValueChange} />\n        {LABLES[0]}\n        <ChooseOptionView\n          value={this.props.values.numberType}\n          onChange={this.onTypeChange}\n          options={INT_SIZES} />\n        {LABLES[1]}\n      </div>\n    );\n  }\n\n  onTypeChange = (newValue: string) => {\n    this.onChange({ numberType: newValue });\n  }\n\n  onValueChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n    // only allow certain input characters: hex and 'o' and 'x' for 0x/0b\n    const newValue = event.target.value;\n    if (/^([0-9a-fA-Fxo]*)$/.test(newValue)) {\n      this.onChange({ numberString: newValue });\n    }\n  }\n\n  onChange(changedValues: any) {\n    this.props.onChange(Object.assign({}, this.props.values, changedValues));\n  }\n}\n\ninterface Props {\n  values: Int.Values,\n  onChange: (newValues: Int.Values) => void,\n}\n","import React from 'react';\nimport * as Str from '../../hex/String';\nimport * as Common from '../../Common';\n\nconst LABELS_NORMAL = [\"Repeat \", \" exactly \", \" time(s)\"];\nconst LABELS_REVERSED = [\"Reverse \", \" and repeat it \", \" time(s)\"];\n\nexport default class StringEditView extends React.Component<Props> {\n  render() {\n    const labels = this.props.values.type === Str.TYPE_REVERSED ?\n      LABELS_REVERSED : LABELS_NORMAL;\n    return (\n      <div>\n        {labels[0]}\n        <input type=\"text\"\n          value={this.props.values.pattern}\n          onChange={this.onPatternChange} />\n        {labels[1]}\n        <input type=\"text\"\n          value={this.props.values.repeatCount}\n          onChange={this.onNumberChange} />\n        {labels[2]}\n      </div>);\n  }\n\n  onNumberChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n    if (Common.isValidRepeatCountWhileEditing(event.target.value)) {\n      this.onChange({ repeatCount: event.target.value });\n    }\n  }\n\n  onPatternChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n    this.onChange({ pattern: event.target.value });\n  }\n\n  onChange(changedValues: any) {\n    this.props.onChange(Object.assign({}, this.props.values, changedValues));\n  }\n}\n\nexport interface Props {\n  values: Str.Values,\n  onChange: (newValues: Str.Values) => void,\n}\n","import React from 'react';\nimport ChooseOptionView from '../ChooseOptionView';\nimport Padding from './PaddingEditView';\nimport Integer from './IntegerEditView';\nimport String from './StringEditView';\nimport * as Int from '../../hex/Integer';\nimport * as Pad from '../../hex/Padding';\nimport * as Str from '../../hex/String';\n\nconst TYPE_MAP = new Map<string, TypeInfos>();\nTYPE_MAP.set(Int.TYPE, { defaultValues: Int.Utils.defaultValues, viewClass: Integer });\nTYPE_MAP.set(Str.TYPE, { defaultValues: Str.Utils.defaultValues, viewClass: String });\nTYPE_MAP.set(Str.TYPE_REVERSED, { defaultValues: Str.ReversedUtils.defaultValues, viewClass: String });\nTYPE_MAP.set(Pad.TYPE, { defaultValues: Pad.Utils.defaultValues, viewClass: Padding });\nconst TYPES = [...TYPE_MAP.keys()];\n\nfunction getTypeInfo(type: string): TypeInfos {\n  let ret = TYPE_MAP.get(type);\n  if (!ret) {\n    throw Error(`Unknown type: ${type}`);\n  }\n  return ret;\n}\n\nexport default class HexElementView extends React.Component<HexElementViewProps, HexElementViewProps> {\n  render() {\n    return (\n      <div className=\"editListView\">\n        {\"Type: \"}\n        <ChooseOptionView value={this.props.data.type} options={TYPES}\n          onChange={this.onTypeChange} />\n\n        {this.renderChild(this.props.data.type)}\n      </div>\n    );\n  }\n\n  onTypeChange = (newType: string) => {\n    this.onChange(newType, getTypeInfo(newType).defaultValues());\n  }\n\n  onChildChange = (newValues: any) => {\n    this.onChange(this.props.data.type, newValues);\n  }\n\n  onChange(newType: string, newValues: any) {\n    const newData = Object.assign(newValues, { type: newType });\n    this.props.onChange(this.props.index, newData);\n  }\n\n  renderChild(type: string): any {\n    const viewClass = getTypeInfo(type).viewClass;\n    const props = {\n      onChange: this.onChildChange,\n      values: this.props.data,\n    };\n    return React.createElement(viewClass, props);\n  }\n\n  typeToClass(type: string): any {\n    let ret = TYPE_MAP.get(type)?.viewClass;\n    if (!ret) {\n      throw Error(`Unknown type: ${type}`);\n    }\n    return ret;\n  }\n};\n\ninterface HexElementViewProps {\n  onChange: (index: number, newValue: any) => void,\n  index: number,\n  data: any,\n}\n\ninterface TypeInfos {\n  defaultValues: any,\n  viewClass: any,\n}\n","import React from 'react';\nimport './App.css';\nimport HexBuilderListView from './app/views/list/ReorderableListView';\nimport OutputView from './app/views/hex/OutputView';\nimport HexElementView from './app/views/hex/HexElementView';\nimport * as Str from './app/hex/String';\n\n// TODO: next steps\n//  - show little endian checkbox if at least one integer is selected\n//  - CSS\n\nexport default class App extends React.Component<any, State> {\n  constructor(props: any) {\n    super(props);\n    this.state = { blueprints: [] }\n  }\n\n  render() {\n    return (\n      <div className=\"app-root\">\n        <a href=\"http://six-two.github.io/react_payload_builder\">\n          View the Gitlab Pages version\n        </a>\n        <HexBuilderListView\n          onChange={this.onListChange}\n          entryClass={HexElementView}\n          newItemData={(index: number) => {\n            var v: any = Str.Utils.defaultValues();\n            v.repeatCount = index + 1;\n            return v;\n          }} />\n        <OutputView blueprints={this.state.blueprints} />\n      </div>\n    );\n  }\n\n  onListChange = (newBlueprints: Blueprint[]) => {\n    this.setState({ blueprints: newBlueprints });\n  }\n}\n\ninterface State {\n  blueprints: Blueprint[],\n}\n\ninterface Blueprint {\n  key: number,\n  data: any,\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}